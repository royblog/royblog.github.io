<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Swift Extension]]></title>
      <url>%2F2017%2F04%2F24%2FSwift-Extension%2F</url>
      <content type="text"><![CDATA[扩展给已经存在的类，结构体，枚举类型和协议增加新的特性。 增加计算实例属性和计算类型属性 定义实例方法和类型方法 提供新的初始化器 定义下标 定义和使用新的内置类型 让一个存在的类型服从一个协议 扩展语法类似Objective-C中的Category，不同的是，Extension没有名字。扩展可以增加新的功能，但是不能覆盖已有的功能。123extension someType &#123; // new functionality to add to SomeType goes here&#125; Extension能拓展存在的类型使其遵守一个或多个协议。123extension someType: SomeProtocol, AnotherProtocol &#123; // implementation of protocol requirements goes here&#125; 计算属性拓展扩展可以给已经存在的类型增加计算实例属性和计算类型属性，如以下扩展了Double类型：1234567891011extension Double &#123; var km: Double &#123; return self * 1_000.0 &#125; var m: Double &#123; return self &#125; var cm: Double &#123; return self / 100.0 &#125; var mm: Double &#123; return self / 1_000.0 &#125; var ft: Double &#123; return self / 3.28084 &#125;&#125;let oneInch = 25.4.mmprint("One inch is \(oneInch) meters")let threeFeet = 3.ftprint("Three feet is \(threeFeet) meters") 构造方法拓展扩展能添加新的构造器，类只能能拓展便利构造期，不能扩展指定构造器。1234567891011121314151617struct Size &#123; var width = 0.0 var height = 0.0&#125;struct Point &#123; var x = 0.0 var y = 0.0&#125;struct Rect &#123; var origin = Point() var size = Size()&#125;let defaultRect = Rect()let memberwiseRect = Rect(origin: Point(x: 2.0, y: 2.0), size: Size(width: 5.0, height: 5.0)) 我们可以为Rect拓展一个构造期(便利构造期)：12345678extension Rect &#123; init(center: Point, size: Size) &#123; let originX = center.x - (size.width / 2) let originY = center.y - (size.height / 2) self.init(origin: Point(x: originX, y: originY), size: size) &#125;&#125; 方法扩展12345678910extension Int &#123; func repetitions(task:() -&gt; Void) &#123; for _ in 0..&lt;self &#123; task() &#125; &#125;&#125;3.repetitions &#123; print("Hello")&#125; 结果为：123HelloHelloHello 可变实例方法扩展扩展增加的实例方法可以修改实例本身。结构体和枚举类型中的方法如果想要修改实例本身或者属性的话需要用mutating来修饰方法，所以扩展这样的方法也需要加mutating。123456789extension Int&#123; mutating func square() &#123; self = self * self print(self) &#125;&#125;var someInt = 3someInt.square() 结果为：19 下标扩展可以给存在的类型增加新的下标，顺序从右往左：12345678910extension Int &#123; subscript(digitIndex: Int) -&gt; Int &#123; var decimalBase = 1 for _ in 0..&lt;digitIndex &#123; decimalBase *= 10 &#125; return (self / decimalBase) % 10 &#125;&#125;345[0] 结果为：15 内置类型拓展能为现存的类，结构体，枚举添加内置类型下面的例子为Int添加一个新的枚举类型Kind，Kind包括正，零，负三种状态。123456789101112131415161718192021222324252627282930extension Int &#123; enum Kind &#123; case negative, zero, positive &#125; var kind: Kind &#123; switch self &#123; case 0: return .zero case let x where x &gt; 0: return .positive default: return .negative &#125; &#125;&#125;func printIntegerKinds(_ numbers: [Int]) &#123; for number in numbers &#123; switch number.kind &#123; case .negative: print("- ", terminator: "") case .zero: print("0 ", terminator: "") case .positive: print("+ ", terminator: "") &#125; &#125; print("")&#125;printIntegerKinds([3, 19, -27, 0, -6, 0, 7]) 结果为：1+ + - 0 - 0 +]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Jinmao Tower Tour]]></title>
      <url>%2F2017%2F04%2F24%2FJinmao-Tower-Tour%2F</url>
      <content type="text"><![CDATA[上海滩三大神楼，注射器、开瓶器、打蛋器。趁着春年花开，阳光明媚，和小伙伴去了 Jinmao Tower。 从注射器看打蛋器 从注射器看开瓶器 从注射器看东方明珠 从注射器向下俯瞰 站在注射器上的我 坐在注射器的我]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift Class Struct Enum]]></title>
      <url>%2F2017%2F04%2F24%2FSwift-Class-Struct-Enum%2F</url>
      <content type="text"><![CDATA[相同点： 三者都可以拥有属性和方法（enum本身不能存储属性，但是可以存储在其关联的信息中，可以有计算属性）。 都可以拥有函数。 class和struct可以拥有自己的构造器。 支持扩展增加功能 可以遵循协议 不同点： 类可以继承。 类可以内省和转化。 struct和enum为值类型，class为引用类型。 class类方法用class关键字声明，enum、struct用static关键字 用mutaing关键词生命要修改struct、enum内容的方法。 结构体适合基本数据类型。 引用类型：(reference types，通常是类)被复制的时候其实复制的是一份引用，两份引用指向同一个对象。值类型：(value types)的每一个实例都有一份属于自己的数据，在复制时修改一个实例的数据并不影响副本的数据。 Enum枚举语法Swift使用enum关键字创建枚举，使用case创建每一个枚举值。和OC不同，Swift枚举不会默认创建分配值。123456enum Student &#123; case pupilStudent case middleStudent case collegeStudent&#125;print(Student.middleStudent) 1结果为：middleStudent 枚举值可以写在同一个case中，使用逗号分割：123enum Teacher &#123; case mathTeacher, chineseTeacher, englishTeacher&#125; 枚举经常和Switch结合使用：123456789var teacher = Teacher.chineseTeacherswitch teacher &#123;case .mathTeacher: print("math teacher")case .chineseTeacher: print("chinese teacher")case .englishTeacher: print("english teacher")&#125; 枚举原始值原始值可以理解为为枚举设置一个具体类型：12345enum Student: String &#123; case pupilStudent = "A" case middleStudent case collegeStudent&#125; 结果为：12AmiddleStudent 如果枚举时Int类型，则会类似于OC，枚举原始值会依次增加：12345678enum Student: Int &#123; case pupilStudent case middleStudent = 13 case collegeStudent&#125;print(Student.pupilStudent.rawValue)print(Student.middleStudent.rawValue)print(Student.collegeStudent.rawValue) 结果为：12301314 枚举相关值（关联值）Swift中的枚举有一个特点，可以设置一些相关值：1234567891011121314enum Student &#123; case pupilStudent(String) case middleStudent(Int, String) case collegeStudent(Int, String)&#125;let stu = Student.collegeStudent(7, "gameing")switch stu &#123;case .pupilStudent(let things): print("is a pupil and \(things)")case .middleStudent(let day, let things): print("is a middle and \(day) days \(things)")case .collegeStudent(let day, let things): print("is college and \(day) days \(things)")&#125; 结果为：1is college and 7 days gameing 枚举递归递归枚举是拥有另一个枚举作为枚举成员关联值的枚举。(递归枚举值必须使用indirect关键字修饰)123456789enum Expression &#123; case num(Int) indirect case add(Expression, Expression) indirect case mul(Expression, Expression)&#125;var exp1 = Expression.num(5)var exp2 = Expression.num(5)var exp3 = Expression.add(exp1, exp2)var exp4 = Expression.mul(exp1, exp3) 如果所有case都是可以递归的：12345indirect enum Expression &#123; case num(Int) case add(Expression, Expression) case mul(Expression, Expression)&#125; Struct结构体定义结构体是由一系列具有相同类型或不同类型的数据构成的数据集合。结构体是一种值类型的数据结构，在Swift中常常使用结构体封装一些属性甚至是方法来组成新的复杂类型，目的是简化运算。我们通过使用关键词 struct 来定义结构体。并在一对大括号内定义具体内容包括他的成员和自定义的方法（是的，Swift中的结构体有方法了），定义好的结构体存在一个自动生成的成员初始化器，使用它来初始化结构体实例的成员属性。废话不多说直接上代码：123456struct Student &#123; var chinese :Int var math: Int var english: Int&#125;let stu = Student(chinese: 89, math: 98, english: 84) 也可以赋初始值：123456struct Student &#123; var chinese :Int = 60 var math: Int = 60 var english: Int = 60&#125;let stu = Student(chinese: 89, math: 98, english: 84) 自定义初始化器123456789101112131415161718192021import Foundationstruct Student &#123; var chinese :Int = 60 var math: Int = 60 var english: Int = 60 init(chinese: Int, math: Int, english: Int) &#123; self.chinese = chinese self.math = math self.english = english &#125; init(stringScore: String) &#123; let cme = stringScore.characters.split(separator: ",") chinese = Int(atoi(String(cme.first!))) math = Int(atoi(String(cme[1]))) english = Int(atoi(String(cme.last!))) &#125;&#125;let stu = Student(chinese: 89, math: 98, english: 84)let stu1 = Student(stringScore: "87,56,83")print(stu1.chinese) 一旦我们自定义了初始化器，系统自动的初始化器就不起作用了，如果还需要使用到系统提供的初始化器，在我们自定义初始化器后就必须显式的定义出来。 定义其它方法如果修改某一个学生的成绩怎么处理，比如修改数学成绩为85:123456789101112struct Student &#123; var chinese :Int = 60 var math: Int = 60 var english: Int = 60 mutating func modifyMathScore(num: Int) &#123; self.math = num &#125;&#125;var stu = Student(chinese: 89, math: 98, english: 84)stu.modifyMathScore(num: 85)print(stu.math) 修改内部变量使用mutating修饰，如果使用使用类方法，使用static修饰函数。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Objective-C Runtime]]></title>
      <url>%2F2017%2F04%2F21%2FObjective-C-Runtime%2F</url>
      <content type="text"><![CDATA[Objective-C Runtime是一个运行时库（Rumtime Library）,可以理解为一个运行时系统。主要使用C语言和汇编语言编写。 Objective-C如何和Runtime打交道？ 通过Objective-C源代码（Objective-C Source Code） 通过Foundation框架中的NSObject定义的方法（NSObject Methods） 通过直接调用runtime函数(Runtime Funcations) 消息机制在大部分情况下，运行时系统（Runtime System）能够在幕后自动处理相关任务，我们仅仅需要写Objective-C代码就可以。当我们编译包含Objective-C类和方法的代码时，编译器创建数据结构和函数调用实现语言的动态性特征。其中比较重要的一个运行时机制是消息机制。 消息机制的大致流程为：首先，Runtime系统将方法调用转化为消息发送，会把1[receive message]; 转化为一个消息函数objc_msgSend：1objc_msgSend(receiver, selector) 如果含有参数，则为：1objc_msgSend(receiver, selector, arg1, arg2, ...) 此时方法调用会通过isa指针找到所属的类，然后检查是否存在相关方法，会先检查缓存中是否有方法（为了提高性能，runtime system 会缓存使用到的selector和方法地址），找到就直接调用方法。如果没有找到，会通过super_class查找父类，如果知道NSObject都没有找到，也没有做任何处理，程序会崩溃，为了防止程序崩溃，可以做消息转发。 上面提到了isa指针，isa是什么呢？OC中大部分对象都继承NSObject,NSObject定义：123@interface NSObject &lt;NSObject&gt; &#123; Class isa OBJC_ISA_AVAILABILITY;&#125; 1typedef struct objc_class *Class; 123struct objc_object &#123; Class isa OBJC_ISA_AVAILABILITY;&#125;; 1typedef struct objc_object *id; 我们可以看出Class是指向objc_class的一个结构体指针，而id是一个指向objc_object结构体的指针，其中的isa是一个指向objc_class结构体的指针。其中的id就是我们所说的对象，Class就是我们所说的类。objc_class定义如下：12345678910111213141516struct objc_class &#123; Class isa OBJC_ISA_AVAILABILITY; #if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; const char *name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; struct objc_method_list **methodLists OBJC2_UNAVAILABLE; struct objc_cache *cache OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; #endif&#125; OBJC2_UNAVAILABLE; 消息转发发送的消息没有被处理，程序就会出错，然而在出错前，运行时机制能给接受对象一个机会处理消息。在错误之前，runtime会发送消息给forwardInvocation：，我们实现forwardInvocation：方法，给消息一个默认的响应即可。 Runtime函数在使用OC编程的时候，大部分不需要直接写Runtime，因为在使用OC的时候，很多内部转化成了Runtime。使用Runtime函数有时能实现某些特殊的效果，下面是runtime常用的函数。runtime常用函数 总结Runtime，在应用中使用广泛，例如消息传递（系统已经帮我们实现），解决字典模型转换问题，快速归档，给对象动态添加变量，动态的添加方法，访问私有变量等。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift Runtime]]></title>
      <url>%2F2017%2F04%2F20%2FSwift-Runtime%2F</url>
      <content type="text"><![CDATA[注：这篇文章原出处来自淘宝技术团队 Objective-C具有动态性，能够通过’runtime API’调用和替换任意方法，那么Swift也具有这些动态性吗？ 用例分析我们拿一个纯Swift类和一个继承自NSObject的类来做分析，这两个类里包含尽量多的Swift的类型比如Character、String、AnyObject、Tuple。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class TestSwiftClass &#123; var aBool: Bool = true var aInt: Int = 0 var aFloat: Float = 12.45 var aDouble: Double = 12.2342 var aString: String = "abc" var aObject: AnyObject! = nil func testReturnVoidWithaId(aId: UIView) &#123; &#125;&#125;class TestSwiftVC: UIViewController &#123; var aBool: Bool = true var aInt: Int = 0 var aFloat: Float = 12.45 var aDouble: Double = 12.2342 var aString: String = "abc" var aObject: AnyObject! = nil override func viewDidLoad() &#123; super.viewDidLoad() &#125; override func viewDidAppear(_ animated: Bool) &#123; super.viewDidAppear(animated) &#125; func testReturnVoidWithaId(aId: UIView) &#123; &#125; func testRetrunVoidWithBool(aBool: Bool, aInteger: Int, aFloat: Float, aDouble: Double, aString: String, aObject: AnyObject) &#123; &#125; func testReturnTuple(aBool: Bool, aInteger: Int, aFloat: Float) -&gt; (Bool, Int, Float) &#123; return (aBool, aInteger, aFloat) &#125; func testReturnVoidWithCharacter(aCharacter: Character) &#123; &#125; func tableView(tableView: UITableView, numberOfRowsSection: Int) -&gt; Int &#123; return 20 &#125;&#125; 方法、属性动态性比较重要的一点就是能够拿到某个类所有的方法、属性，我们使用如下代码来打印方法和属性列表。1234567891011121314151617181920212223242526func showClsRuntime(cls: AnyClass) &#123; print("start methodList") var methodNum: UInt32 = 0 let methodList = class_copyMethodList(cls, &amp;methodNum) for index in 0..&lt;numericCast(methodNum) &#123; let method: Method = methodList![index]! print(String(_sel: method_getName(method))) &#125; print("end methodList") print("start propertyList") var propertyNum: UInt32 = 0 let propertyList = class_copyPropertyList(cls, &amp;propertyNum) for index in 0..&lt;numericCast(propertyNum) &#123; let property: objc_property_t = propertyList![index]! print(String.init(utf8String: property_getName(property)) ?? "") &#125; print("end propertyList")&#125;let aSwifterClass : TestSwiftClass = TestSwiftClass()showClsRuntime(cls: object_getClass(aSwifterClass))print("\n")let aSwiftVC: TestSwiftVC = TestSwiftVC()showClsRuntime(cls: object_getClass(aSwiftVC)) 执行上面代码结果：12345678910111213141516171819202122232425262728293031323334353637start methodListend methodListstart propertyListend propertyListstart methodList.cxx_destructinitWithNibName:bundle:viewDidAppear:viewDidLoadinitWithCoder:aBoolsetABool:aIntsetAInt:aFloatsetAFloat:aDoublesetADouble:aStringsetAString:aObjectsetAObject:testReturnVoidWithaIdWithAId:testRetrunVoidWithBoolWithABool:aInteger:aFloat:aDouble:aString:aObject:tableViewWithTableView:numberOfRowsSection:end methodListstart propertyListaBoolaIntaFloataDoubleaStringaObjectend propertyList 结论： 对于纯Swift的TestSwiftClass来说任何方法、属性都未获取到 对于TestSwiftVC，除了testReturnTuple，testReturnVoidWithCharacter两个方法外，其它都获得成功。原因： 纯Swift类的函数调用已经不再是Objective-c的运行时发消息，而是类似C++的vtable，在编译时就确定了调用哪个函数，所以没法通过runtime获取方法、属性。TestSwiftVC继承自UIViewController，基类为NSObject，而Swift为了兼容Objective-C，凡是继承自NSObject的类都会保留其动态性，所以我们能通过runtime拿到他的方法。testReturnTuple，testReturnVoidWithCharacter获取不到是因为：从Objective-c的runtime 特性可以知道，所有运行时方法都依赖TypeEncoding，而Character和Tuple是Swift特有的，无法映射到OC的类型，更无法用OC的typeEncoding表示，也就没法通过runtime获取了。 Method Swizzing动态性最常用的就是方法替换（Method Swizzling），将类的某个方法替换成自定义的方法，从而达到hook的作用。 对于纯Swift类（如TestSwiftClass）来说，无法通过objc runtime替换方法，因为由上面的测试可知拿不到这些方法、属性 对于继承自NSObject类（如TestSwiftVC）来说，无法通过runtime获取到的方法肯定没法替换了。那能通过runtime获取到的方法就都能被替换吗？我们测一把。我们替换两个可以被runtime获取到的方法：viewDidAppear和testReturnVoidWithaId替换代码：123456789101112func methodSwizze(cls: AnyClass, originalSelector: Selector, swizzledSelector: Selector) &#123; let originalMethod = class_getInstanceMethod(cls, originalSelector) let swizzledMethod = class_getInstanceMethod(cls, swizzledSelector) let didAddMethod = class_addMethod(cls, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)) if didAddMethod &#123; class_replaceMethod(cls, swizzledSelector ,method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)) &#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod) &#125;&#125; viewDidAppear可以替换掉，testReturnVoidWithaId不能替换，通过代码调试，可以看到viewDidAppear会有@objc标识，testReturnVoidWithaId没有标识。@objc用来做什么的？与动态性有关吗？@objc是用来将Swift的API导出给Objective-C和Objective-C runtime使用的，如果你的类继承自Objective-c的类（如NSObject）将会自动被编译器插入@objc标识。我们在把TestSwiftClass（纯Swift类）的方法、属性前都加个@objc 试试，如图：123456789101112class TestSwiftClass &#123; @objc var aBool: Bool = true @objc var aInt: Int = 0 @objc var aFloat: Float = 12.45 @objc var aDouble: Double = 12.2342 @objc var aString: String = "abc" @objc var aObject: AnyObject! = nil @objc func testReturnVoidWithaId(aId: UIView) &#123; &#125;&#125; 查看日志可以发现加了@objc的方法、属性均可以被runtime获取到了。123456789101112131415161718192021222324start methodListaBoolsetABool:aIntsetAInt:aFloatsetAFloat:aDoublesetADouble:aStringsetAString:aObjectsetAObject:testReturnVoidWithaIdWithAId:end methodListstart propertyListaBoolaIntaFloataDoubleaStringaObjectend propertyList 加了@objc标识的方法、属性无法保证都会被运行时调用，因为Swift会做静态优化。要想完全被动态调用，必须使用dynamic修饰。使用dynamic修饰将会隐式的加上@objc标识,这也就解释了为什么testReturnVoidWithaId无法被替换，因为写在Swift里的代码直接被编译优化成静态调用了。而viewDidAppear是继承Objective-C类获得的方法，本身就被修饰为dynamic，所以能被动态替换。我们把TestSwiftVC方法前加上dynamic再测一把，从堆栈也可以看出，方法的调用前增加了@objc标识，testReturnVoidWithaId方法被替换成功了。 总结 纯Swift类没有动态性，但在方法、属性前添加dynamic修饰可以获得动态性。 继承自NSObject的Swift类，其继承自父类的方法具有动态性，其他自定义方法、属性需要加dynamic修饰才可以获得动态性。 若方法的参数、属性类型为Swift特有、无法映射到Objective-C的类型(如Character、Tuple)，则此方法、属性无法添加dynamic修饰（会编译错误） Swift类在Objective-C中会有模块前缀]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift Key-Value Observing]]></title>
      <url>%2F2017%2F04%2F20%2FSwift-Key-Value-Observing%2F</url>
      <content type="text"><![CDATA[KVO（Key-Value Observing）是为了其他不同实例对当前的某个属性 (严格来说是 keypath) 进行监听时使用的。其他实例可以充当一个订阅者的角色，当被监听的属性发生变化时，订阅者将得到通知。这是一个很强大的属性，通过 KVO 我们可以实现很多松耦合的结构，使代码更加灵活和强大：像通过监听 model 的值来自动更新 UI 的绑定这样的工作，基本都是基于 KVO 来完成的。在 Swift 中我们也是可以使用 KVO 的，但是仅限于在 NSObject 的子类中。这是可以理解的，因为 KVO 是基于 KVC (Key-Value Coding) 以及动态派发技术实现的，而这些东西都是 Objective-C 运行时的概念。另外由于 Swift 为了效率，默认禁用了动态派发，因此想用 Swift 来实现 KVO，我们还需要做额外的工作，那就是将想要观测的对象标记为 dynamic。 官方代码123456789101112131415161718192021222324252627282930313233class MyObjectToObserve: NSObject &#123; dynamic var myDate = NSDate() func updateDate() &#123; myDate = NSDate() &#125;&#125;private var myContext = 0class MyObserver: NSObject &#123; var objectToObserve = MyObjectToObserve() override init() &#123; super.init() objectToObserve.addObserver(self, forKeyPath: #keyPath(MyObjectToObserve.myDate), options: .new, context: &amp;myContext) &#125; override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) &#123; if context == &amp;myContext &#123; if let newValue = change?[.newKey] &#123; print("Date changed: \(newValue)") &#125; &#125; else &#123; super.observeValue(forKeyPath: keyPath, of: object, change: change, context: context) &#125; &#125; deinit &#123; objectToObserve.removeObserver(self, forKeyPath: #keyPath(MyObjectToObserve.myDate), context: &amp;myContext) &#125;&#125;let obj = MyObserver()obj.objectToObserve.updateDate() 首先是 Swift 的 KVO 需要依赖的东西比原来多。在 Objective-C 中我们几乎可以没有限制地对所有满足 KVC 的属性进行监听，而现在我们需要属性有 dynamic 进行修饰。大多数情况下，我们想要观察的类不一定是 dynamic 修饰的 (除非这个类的开发者有意为之，否则一般也不会有人愿意多花功夫在属性前加上 dynamic，因为这毕竟要损失一部分性能)，并且有时候我们很可能也无法修改想要观察的类的源码。遇到这样的情况的话，一个可能可行的方案是继承这个类并且将需要观察的属性使用 dynamic 进行重写。比如刚才我们的 MyObjectToObserve 中如果 date 没有 dynamic 的话，我们可能就需要一个新的 OtherMyObjectToObserve 了：1234567891011121314151617class MyObjectToObserve: NSObject &#123; var myDate = NSDate() func updateDate() &#123; myDate = NSDate() &#125;&#125;class OtherMyObjectToObserve: MyObjectToObserve &#123; dynamic override var myDate: NSDate &#123; get &#123; return super.myDate &#125; set &#123; super.myDate = newValue &#125; &#125;&#125; KVO代码使用的是苹果官方示例]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift Key-Value Coding]]></title>
      <url>%2F2017%2F04%2F20%2FSwift-Key-Value-Coding%2F</url>
      <content type="text"><![CDATA[KVC (Key-Value Coding)， 它是一种用间接方式访问类的属性的机制。在 Swift 中为一个类实现 KVC 的话，需要让它继承自 NSObject。 Code12345678910class Person: NSObject &#123; var firstName: String var lastName: String init(firstName: String, lastName: String) &#123; self.firstName = firstName self.lastName = lastName &#125;&#125; let roy = Person(firstName: "roy", lastName: "wang") 直接引用属性： 1print(roy.lastName) 通过KVC机制访问：123if let newValue = roy.value(forKey: "lastName") &#123; print(newValue)&#125; 如果使用KVC获取一个不存在的key，会导致程序崩溃。找不到key，会调用valueForUndefinedKey，我们可以重新此方法：12345678910111213class Person: NSObject &#123; var firstName: String var lastName: String init(firstName: String, lastName: String) &#123; self.firstName = firstName self.lastName = lastName &#125; override func value(forUndefinedKey key: String) -&gt; Any? &#123; return "" &#125;&#125; KVC 除了可以用单个的 key 来访问单个属性，还提供了一个叫做 keyPath 的东西。所谓 keyPath，就比如你的属性本身也有自己的属性，那么想引用这个属性，就需要用到 keyPath。咱们用一个示例来说明：12345678910111213141516171819class Province: NSObject &#123; var proName: String init(proName: String) &#123; self.proName = proName &#125;&#125;class Country: NSObject &#123; var conName: String var conProvince: Province init(conName: String, conProvince: Province) &#123; self.conName = conName self.conProvince = conProvince &#125;&#125;var con = Country(conName: "CN", conProvince: Province(proName: "HenanProvince"))print(con.value(forKeyPath: "conProvince.proName")) KVC 定义了使用 valueForKey获取属性，同样也提供了设置属性的方法 setValue:forKey1con.setValue("US", forKey: "conName") 标量值所谓标量值（Scalar Type）就是简单的类型的属性，比如int，float，这些非对象属性，关于标量值在KVC中有些地方需要注意：12345678910111213class Person: NSObject &#123; var firstName: String var lastName: String var age: Int init(firstName: String, lastName: String, age: Int) &#123; self.firstName = firstName self.lastName = lastName self.age = age &#125;&#125;let roy = Person(firstName: "roy", lastName: "wang", age: 14)roy.setValue(nil, forKey: "age") age是一个简单标量值，标量值不能为nil,虽然setValue 方法可以接受任何类型的参数作为值的设置，但 age 的底层存储确实标量值，因此我们执行上面那条 setValue 语句的时候必然会造成程序的崩溃。那么我们除了注意避免将 nil 传递给底层存储是标量类型的属性之外，还有没有其他方法呢？KVC 为我们提供了一个 setNilValueForKey 方法，每当我们要将 nil 设置给一个 key 的时候，这个方法就会被调用，所以我们可以修改一下 Person 类的定义： 1234567891011121314151617class Person: NSObject &#123; var firstName: String var lastName: String var age: Int init(firstName: String, lastName: String, age: Int) &#123; self.firstName = firstName self.lastName = lastName self.age = age &#125; override func setNilValueForKey(_ key: String) &#123; if key == "age" &#123; self.setValue(18, forKey: "age") &#125; &#125;&#125; FAQ实现KVC，为什么要继承 NSObject KVC 机制是由一个协议 NSKeyValueCoding 定义的。NSObject 帮我们实现了这个协议，所以 KVC 核心的逻辑都在 NSObject 中，我们继承 NSObject 才能让我们的类获得 KVC 的能力。(理论上说，如果你遵循 NSKeyValueCoding 协议的接口，其实也可以自己实现 KVC 的细节，完全行得通。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift Optional]]></title>
      <url>%2F2017%2F04%2F20%2FSwift-Optional%2F</url>
      <content type="text"><![CDATA[Optional定义Optional是在Swift中引入的新类型，特点是可以有值，也没有没有值，没有值为nil。Optional其实就是一个枚举： 1234567891011public enum Optional&lt;Wrapped&gt; : ExpressibleByNilLiteral &#123; case none case some(Wrapped) public init(_ some: Wrapped) public func map&lt;U&gt;(_ transform: (Wrapped) throws -&gt; U) rethrows -&gt; U? public func flatMap&lt;U&gt;(_ transform: (Wrapped) throws -&gt; U?) rethrows -&gt; U? public init(nilLiteral: ()) public var unsafelyUnwrapped: Wrapped &#123; get &#125;&#125; 当Optional没有值时，返回的nil其实就是Optional.None，即没有值。除了None以外，还有一个Some，当有值时就是被Some包装的真正的值，所以我们拆包的动作其实就是将Some里面的值取出来。 Optional使用我们可以声明一个 Optional 的 String 类型的变量，只需要在变量定义的时候在类型后面加上一个 ? 1var optionalString: String? 在引用的时候，我们需要强制拆包，在变量后面添加一个 ! ，相当于告诉编译器，我确信这个变量不是 nil，可以直接使用（当然，使用强制解包只代表你自己确认它不为 nil，但它还是有可能为 nil 的，如果这样的情况发生，依然会造成程序运行时崩溃）。1print(optionalString!) 使用 if let 这样的语法就可以更加安全的操作 Optional 值。只有在 name 中的值不为 nil 的时候，nameValue 变量才会被初始化成功。 这样我们的 print 语句就不会因为 nil 而崩溃。相比使用强制解包，更加安全和优雅的方式是使用 Optional Chaining：123if let newValue = optionalString &#123; print(newValue)&#125; Optional Chaning 陷阱123456789101112struct Name &#123; var firstName: String = "" var lastName: String = ""&#125;struct Person &#123; var name: Name? var age: Int&#125;var person: Person? = Person(name: Name(firstName: "roy", lastName: "wang"), age: 25)print(person?.name?.firstName) 上面的输入结果是：1Optional("roy") firstName不是可选类型，为什么输出结果是这样呢。因为在表达式中只要有一个是可选值，整个表达式结果都是Optional。如果person为nil，后面的引用就没有了意义，所以我们需要对这个表达式做处理。正确的引用方式应该是这样的：123if let firstName = person?.name?.firstName &#123; print(firstName)&#125; Optional Chaning 作为返回值也需要注意，如下：123func getName(person: Person) -&gt; String &#123; return person.name?.firstName&#125; 上面的代码不会通过编辑，因为返回值是Optional Chaning，所以下面的才是正确的打开方式：123func getName(person: Person) -&gt; String? &#123; return person.name?.firstName&#125; 实际应用123456789class WebViewDelegate :NSObject, UIWebViewDelegate &#123; func webView(webView: UIWebView, shouldStartLoadWithRequest request: NSURLRequest, navigationType: UIWebViewNavigationType) -&gt; Bool &#123; if let absURL = request.URL?.absoluteString &#123; // do something.. return false &#125; return true &#125;&#125; 不要天真的这样使用,编译会出错的：12if request.URL?.absoluteString == "xxx" &#123;&#125; 为什么要有Optional因为Swift是强类型语言。引入 Optional 机制是为了「更严格的」类型检查，使得在编译时可以发现更多问题（未预期的变量为空）。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift Singleton]]></title>
      <url>%2F2017%2F04%2F19%2FSwift-Singleton%2F</url>
      <content type="text"><![CDATA[单例必须是唯一的，在程序生命周期中只能存在一个这样的实例。为保证单例的唯一性，单例类的初始化方法必须是私有的。这样就可以避免其他对象通过单例类创建额外的实例。为保证在整个程序的生命周期中值有一个实例被创建，单例必须是线程安全的。 在Swift中单例实现比较简单：1234class TheOneAndOnly &#123; static let shareInstance = TheOneAndOnly() private init() &#123;&#125;&#125; 全局变量（还有结构体和枚举体的静态成员）的Lazy初始化方法会在其被访问的时候调用一次。类似于调用’dispatch_once’以保证其初始化的原子性。这样就有了一种很酷的’单次调用’方式：只声明一个全局变量和私有的初始化方法即可。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift GCD]]></title>
      <url>%2F2017%2F04%2F19%2FSwift-GCD%2F</url>
      <content type="text"><![CDATA[GCDGrand Central Dispatch (GCD)是Apple开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并行任务。在Mac OS X 10.6雪豹中首次推出，也可在IOS 4及以上版本使用。 基本概念 进程：正在进行中的程序被称为进程，负责程序运行的内存分配;每一个进程都有自己独立的虚拟内存空间 线程：线程是进程中一个独立的执行路径(控制单元);一个进程中至少包含一条线程，即主线程 队列：是管理线程的，相当于线程池,能管理线程什么时候执行。无论什么队列和任务，线程的创建和回收不需要程序员操作，由队列负责。 串行队列：队列中的任务只会顺序执行。 并行队列：队列中的任务通常会并发执行。 全局队列：是系统的，与并行队列类似，但调试时，无法确认操作所在队列 主队列：每一个应用程序对应唯一一个主队列，在多线程开发中，使用主队列更新UI。 串行队列同步：操作不会新建线程、操作顺序执行。 串行队列异步：操作需要一个子线程，会新建线程、线程的创建和回收不需要程序员参与，操作顺序执行，“最安全的选择”。 并行队列同步：操作不会新建线程、操作顺序执行。 并行队列异步：操作会新建多个线程（有多少任务，就开N个线程执行）、操作无序执行；队列前如果有其他任务，会等待前面的任务完成之后再执行；场景：既不影响主线程，又不需要顺序执行的操作！ 全局队列异步：操作会新建多个线程、操作无序执行，队列前如果有其他任务，会等待前面的任务完成之后再执行。 全局队列同步：操作不会新建线程、操作顺序执行。 主队列：操作在主线程上顺序执行，不存在异步。 图说概念 串行队列 并行队列 全局队列 同步 不创建线程，顺序执行 不创建线程，顺序执行 不创建线程，顺序执行 异步 创建一个线程，顺序执行 创建多个线程，并发执行 创建多个线程，并发执行 代码示例在我们使用多线程的时候，主要是处理并发事件，使用下面的代码能够解决大部分场景：12345678DispatchQueue.global().async &#123; print("开始执行异步任务") Thread.sleep(forTimeInterval: 2) print("异步任务执行完毕") DispatchQueue.main.async &#123; print("回到UI线程") &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MarkDown File]]></title>
      <url>%2F2017%2F04%2F18%2FMarkDown-File%2F</url>
      <content type="text"><![CDATA[Markdown使用笔记 创建表格12345| Tables | col1 | col2 || :----: |:-----:|:----:|| a | b | c || d | e | f || g | h | i | 效果如下： Tables col1 col2 a b c d e f g h i 索引1&gt; 添加引用内容 效果如下： 这是引用内容 分割线1*** 效果如下： 加粗1** 加粗内容 ** 效果如下： 这是加粗内容 超链接1[这是百度首页](www.baidu.com) 效果如下：这是百度首页 图片1![这是一张图片](http://roywyg.oss-cn-shanghai.aliyuncs.com/Image/6F5895E3F6953A91FFDB56D212461762.jpg) 效果如下： 字体1# 字体1, ## 字体2, ### 字体3,#### 字体4,##### 字体5,###### 字体6 效果如下： 字体1,字体2字体3字体4字体5字体6斜体1*这是斜体* 效果如下：这是斜体 无序列表12* this one* this two 效果如下： this one this two 有序列表121. this is order one 2. this is order two 效果如下： this is order one this is order two 脚注1[^content] 效果如下：[^mark] : 《百科全书》 行内代码1这是行内`行内`代码 效果如下：这是行内行内代码 代码块效果如下：1这是代码块 删除线1~~删除~~ 效果如下：删除]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift Define]]></title>
      <url>%2F2017%2F04%2F18%2FSwift-Define%2F</url>
      <content type="text"><![CDATA[宏定义合理使用能够使代码漂亮简洁，但是使用宏定义有时也会导致难以重构和维护，隐藏很多问题。在Swift中已经去掉了宏定义，并且苹果公司给了一些替代建议，比如使用let和get代替原来的宏定义。 没有参数的宏在OC中 12#define kScreenHeight [UIScreen mainScreen].bounds.size.height#define kScreenWidth [UIScreen mainScreen].bounds.size.width 在Swift中 12let kScreenHeight = UIScreen.mainScreen().bounds.size.heightlet kScreenWidth = UIScreen.mainScreen().bounds.size.width 接收参数的宏在OC中 1#define RGBCOLOR(r,g,b) [UIColor colorWithRed:(r)/255.0 green:(g)/255.0 blue:(b)/255.0 alpha:1] 在Swift中 1234func RGBCOLOR(_ r:CGFloat,_ g:CGFloat,_ b:CGFloat) -&gt; UIColor&#123; return UIColor(red: (r)/255.0, green: (g)/255.0, blue: &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift Lock]]></title>
      <url>%2F2017%2F04%2F18%2FSwift-Lock%2F</url>
      <content type="text"><![CDATA[在不同线程中安全的访问同一资源，需要为资源加上线程锁，否则多个线程访问同一资源，会导致结果不可预测。在OC中使用@synchronized为资源加锁，但是在Swift中这个方法已经不存在了。@synchronized幕后所做的工作是调用objc_sync中的objc_sync_enter和objc_sync_exit方法。在Swift中lock一个变量可以使用：12345func myMethod(anObj: AnyObject!) &#123; objc_sync_enter(anObj) //在enter 和 exit 之间 anObj不会被其它线程改变 objc_sync_exit(anObj)&#125; 加锁和解锁都需要消耗性能，我们不可能为所有方法都加上锁，并且在App中涉及多线程部分有限，也没有必要为所有东西加锁。过多的锁没有意义，不但会消耗性能，也有可能会导致死锁问题。在处理多线程时，尽量保持简单。 Swift Lock]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift Add Variable For A Exist Class]]></title>
      <url>%2F2017%2F04%2F18%2FSwift-Add-Variable-For-A-Exist-Class%2F</url>
      <content type="text"><![CDATA[在Swift中如何为一个存在的类添加变量，新建一个Person.swift文件，代码如下：12345678import Foundationclass Person: NSObject &#123; var name: NSString? func eatFood() -&gt; Void &#123; print("People can eat") &#125;&#125; 现在新建PersonExtension.swift，代码如下： 123456789101112131415import Foundationprivate var key: Void?extension Person &#123; var gender: String? &#123; get &#123; return objc_getAssociatedObject(self, &amp;key) as? String &#125; set &#123; return objc_setAssociatedObject(self, &amp;key, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC) &#125; &#125;&#125; 现在我们则为Person新添加了一个变量,可以使用一下代码访问新变量 1234let per = Person()per.name = "roy"per.gender = "boy"per.eatFood()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift Navi Title Offset]]></title>
      <url>%2F2017%2F04%2F18%2FSwift-Navi-Title-Offset%2F</url>
      <content type="text"><![CDATA[在iOS中，导航栏的标题有时不居中显示，问题的原因是前一个导航页面标题太长，进入下一个界面的时候，下个界面的标题会向后偏移，导致标题不居中显示。问题的解决方案有多种，在此说一下我的解决方案，因为项目中有基类控制器，在基类控制器的viewDidLoad方法中，添加以下代码：1234567891011NSArray *viewControllerArray = [self.navigationController viewControllers];long previousViewControllerIndex = [viewControllerArray indexOfObject:self] - 1;UIViewController *previous;if (previousViewControllerIndex &gt;= 0) &#123; previous = [viewControllerArray objectAtIndex:previousViewControllerIndex]; previous.navigationItem.backBarButtonItem = [[UIBarButtonItem alloc] initWithTitle:@"" style:UIBarButtonItemStylePlain target:self action:nil];&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift Generic Base]]></title>
      <url>%2F2017%2F04%2F17%2FSwift-Generic-Base%2F</url>
      <content type="text"><![CDATA[Swift创始人Chirs Lattner: 1Swift引入泛型和函数式编程的思想，极大地扩展了设计的空间。 什么是泛型？以下面两个例子说明什么是泛型 两值是否相等问题 两值交换问题 两值是否相等问题判断两值是否相等我们的常规思路如下： 123456789func equalInt(numOne: Int, numbTwo: Int) -&gt; Bool &#123; return numOne == numbTwo&#125;equalInt(numOne: 4, numbTwo: 4)func equalString(strOne: String, strTwo: String) -&gt; Bool &#123; return strOne == strTwo&#125;equalString(strOne: "roy", strTwo: "note") 我们需要为每一种类型写一种方法，一句话总结就是写的很不爽，下面就该泛型登场了 123456789func isEquals&lt;T: Comparable&gt;(a: inout T, b: inout T) -&gt; Bool &#123; return (a == b)&#125;var num1 = 5var num2 = 5var str1 = "wyg"var str2 = "roy"isEquals(a: &amp;num1, b: &amp;num2)isEquals(a: &amp;str1, b: &amp;str2) 并不是所有的类型都具有可比性，必须遵守Comparable协议，在Swift中，基本数据类型和字符串都遵守Comparable协议。 两值交换问题有了上面例子铺垫，直接使用泛型来实现 12345678910func swapTwoValue&lt;T&gt;(a: inout T, b: inout T) &#123; let tempValue = a a = b b = tempValue&#125;var oneStr = "hello"var twoStr = "world"swapTwoValue(a: &amp;oneStr, b: &amp;twoStr)print(oneStr,twoStr) 类型参数在上面的泛型函数例子中，占位符T是类型参数的一个例子。类型参数指定并命名一个占位符类型，并用&lt;&gt;包裹，放在函数名后面。一旦一个参数类型确定，就可以指定参数类型，或者返回值的类型，还可以用作函数体的注释类型。在调用的时候会被实际的类型替代，如传递的是Int，就替换为Int，如果传入的是Double类型就替换为Double等等]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift Underline]]></title>
      <url>%2F2017%2F04%2F17%2FSwift-UnderLine%2F</url>
      <content type="text"><![CDATA[在Swift中下划线用途多样，下面列举几种常见用法。 1.格式化数字字面量提高数字字面量的可读性。1let oneMillion = 1_000_000 //(is equal to 1,000,000) 2.忽略元组元素值使用元组时，有元素不必使用时，可以使用下划线将元素忽略。12let http404Error = (404, "Not Found")let(_, errorMessage) = http404Error 3.忽略区间值123456let base = 3let power = 10var answer = 1for _ in 1...power &#123; answer *= base&#125; 4.忽略外部参数名123456789func cal(num1: Int, num2: Int) -&gt; Int &#123; return num1 + num2&#125;cal(num1: 15, num2: 15)func sum(_ num1: Int, _ num2: Int) -&gt; Int &#123; return num1 + num2&#125;sum(15, 15) 参考：@Author:twlkyao]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[My Family]]></title>
      <url>%2F2017%2F04%2F14%2FMy-Family%2F</url>
      <content type="text"><![CDATA[用博客存储图片也不错哦。 1能认出我的人，奖励一颗超级无敌泡泡糖。 1杭州爬山。 1和家里小伙伴的合影 1这张是全家福 1这张拍于某年某月某一天的照片]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS Books]]></title>
      <url>%2F2017%2F04%2F13%2FiOS-Books%2F</url>
      <content type="text"><![CDATA[刚才整理电脑，在某个很久很久没被我光顾的角落里，静静地躺着几本书。虽然这些书稍微有点落后，并且从网上也能找到相关资源，但是也厚着脸皮拿出来和大家共享一下吧，书不多，等有时间，把相关题材的书籍再统一整理，后续更新一下。 iOS开发指南：从零基础到APP Store上架，第二版）iOS网络编程与云端应用最佳实践企业级iOS应用开发实战object_c编程之道iOS设计模式解析]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python Books]]></title>
      <url>%2F2017%2F04%2F13%2FPython-Books%2F</url>
      <content type="text"><![CDATA[在此和大家分享几本和Python相关的书籍，其中有基本教程，核心教程，也有和网络爬虫和黑客相关的书籍。 Python网络数据采集汉化版Python网络数据采集英文版Python基础教程，第二版Python核心教程，第三版Python绝技，运用python成为顶级黑客，汉化版Python绝技，运用python称为顶级黑客，英文版]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift Start]]></title>
      <url>%2F2017%2F04%2F13%2FSwift-Start%2F</url>
      <content type="text"><![CDATA[Swift语言，是苹果在2014年WWDC发布的新开发语言，是未来趋势，将来必定会替代Objective-C。但是新事物的成长历程历来是前途是光明的，道路是曲折的，所以目前开发者还是主要以使用Objective-C为主，作为一名开发者，对于新技术应该是趋之若鹜，因为公司一直使用的Objective-C语言，再加上自己的一点懒惰之心，Swift的学习到目前为止只看了官方文档，并没有进行深入学习和项目实践，为了牢记落后就没有工资的历史遗训，决定好好学习Swift语言。 有人说，苹果公司推出Swift语言，是为了弥补Objective-C的技术债，我对这样的说辞以前从不以为然，心里暗暗嘀咕，这肯定是苹果公司放出的风声，为了鼓励开发者使用Swift语言。但是身边的朋友使用Swift的渐渐多了起来，他们的反馈一致是“我已经回不了头了，Swift真的是太方便了”。我只能仰天长叹，此时不学，更待何时。 一些新事物刚出来，我们不以为然，认为不重要，但是当你真正接触了之后，就再也难以忍受失去它，就比如当时ARC推出来很多人不接受，现在大家都在使用ARC。新事物有不稳定性，脆弱性，很容易夭折，但是新事物也往往孕育着更大的生命力。1Result：近期我要深入研究Swift语言。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F04%2F12%2Fhello-world%2F</url>
      <content type="text"><![CDATA[对于一枚码农，刚接触编程的时候，写的第一行代码，很有可能是打印“Hello World”，今天使用Github+Hexo实现了一个简易的博客，就用Hello World和大家打声招呼吧。 为什么要开通博客？ 记录，好记性不如写博客，不管是平时的学习笔记，突然来的灵感，还是思考的一些心得体会，都可以记录下来，方便以后查阅。 分享，写日记是私有行为，写博客公有属性，把自己的一些经历或经验和大家一起分享，说不定你的分享对于某一个人大有裨益。 交流，把自己的思想和大家分享，别人对此评头论足一定是好事，人有局限性，汇聚更多的思想，才能将局限缩小。 有这么多开放平台，为什么要自己动手搭建博客？ 自己动手，丰衣足食。 作为技术开发，没有自己的博客，总感觉人生缺少点什么。 有很多开源的博客，搭建博客的时间成本，技术成本，经济成本都很低。 可以装逼，这点很重要。]]></content>
    </entry>

    
  
  
</search>
